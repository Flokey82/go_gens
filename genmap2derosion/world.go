// Package genmap2derosion is based on "Simple Hydrology"
// See: https://nickmcd.me/2020/04/15/procedural-hydrology/
package genmap2derosion

import (
	"fmt"
	"image"
	"image/color"
	"math/rand"

	"github.com/Flokey82/go_gens/vectors"
)

const worldsize = 256

type Params struct {
	StoreGIFFrames bool
	StorePNGCycles bool
	Height         int64
	Width          int64
	Seed           int64
	Size           vectors.IVec2
}

var DefaultParams = &Params{
	StoreGIFFrames: true,
	StorePNGCycles: true,
	Seed:           DefaultSeed,
	Size: vectors.IVec2{
		X: worldsize,
		Y: worldsize,
	},
}

type World struct {
	r       *rand.Rand
	params  *Params
	images  []*image.Paletted // Generated frame used to construct the GIF.
	palette []color.Color     // Default color palette.
	delays  []int             // Delay for each individual frame (0 for now).

	drainage    float64   // Drainage factor from pools
	scale       float64   // "Physical" Height scaling of the map
	heightmap   []float64 // Flat Array containing height information
	sediment    []float64 // Sediment storage (stores information on eroded / deposited sediment)
	waterpath   []float64 // Water Path Storage (Rivers)
	waterpool   []float64 // Water Pool Storage (Lakes / Ponds)
	waterdrains []int     // Water Pool drainage points

	// Flux related information (experimental)
	fluxwaterpool []float64 // (TEMP Flux) Water Pool Storage (Lakes / Ponds)

	// Trees
	// trees []Plant
	// plantdensity [worldsize * worldsize]float64 //Density for Plants

	// Sediment erosion resistance
	// sedimentToughness [worldsize * worldsize]float64 // Sediment toughness storage
}

const DefaultSeed = 12356

func NewWorld(params *Params) *World {
	if params == nil {
		params = DefaultParams
	}

	idxSize := params.Size.X * params.Size.Y
	w := &World{
		params:        params,
		r:             rand.New(rand.NewSource(params.Seed)),
		drainage:      0.01,
		scale:         40.0,
		heightmap:     make([]float64, idxSize),
		sediment:      make([]float64, idxSize),
		waterpath:     make([]float64, idxSize),
		waterpool:     make([]float64, idxSize),
		waterdrains:   make([]int, idxSize),
		fluxwaterpool: make([]float64, idxSize),
	}

	// Prepare grayscale palette for GIF (0-255).
	for i := 0; i <= 255; i++ {
		w.palette = append(w.palette, color.RGBA{uint8(i), uint8(i), uint8(i), 0xff})
	}

	// Initialize all water drains to -1 (unset)
	for i := range w.waterdrains {
		w.waterdrains[i] = -1
	}

	// Generate basic heightmap.
	w.genTerrain()

	// Generate climate.
	w.genClimate()

	fmt.Println("generated")

	// Erode a few times.
	for j := 0; j < 5; j++ {
		w.doErosion(50, 300)
		// c := w.genClimate()
		// TODO: Update heightmap in climate struct.
		// w.erodeRain(1, c.AvgRainMap)

		// Export hydrology data generated by the original algorithm.
		if w.params.StorePNGCycles {
			w.ExportPng(fmt.Sprintf("b_image%d.png", j), w.heightmap)
			w.ExportPng(fmt.Sprintf("b_image%d_wp.png", j), w.waterpath)
			w.ExportPng(fmt.Sprintf("b_image%d_wpo.png", j), w.waterpool)
			w.ExportPng(fmt.Sprintf("b_image%d_sed.png", j), w.sediment)
			w.exportCombined(fmt.Sprintf("b_image%d_combo.png", j), w.heightmap, w.waterpath, w.waterpool)
		}

		// Optional stuff...

		// Call downhill, which will generate flux information.
		// for i, dhs := range w.getDownhill() {
		// 	if len(dhs) == 0 {
		// 		fmt.Println(fmt.Sprintf("sink: %d", i))
		// 	}
		// }

		// Export alternative hydrology data generated through flux.
		// w.export(fmt.Sprintf("b_image%d_flux_raw.png", j), w.getRawFlux())
		// w.export(fmt.Sprintf("b_image%d_flux.png", j), w.getFlux())
		// w.export(fmt.Sprintf("b_image%d_flux_wpo.png", j), w.fluxwaterpool[:])
	}
	return w
}
